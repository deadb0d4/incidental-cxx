// autogenerated every build
#include <{{ parser.cpp_include_name() }}>

#include <unordered_set>
#include <stdexcept>
#include <string>

namespace argparse::parsers {

namespace {

bool IsIntArg(std::string_view str) {
  if (str.empty()) {
    return false;
  }
  if (str[0] != '-' and not std::isdigit(str[0])) {
    return false;
  }
  for (size_t i = 1; i < str.size(); ++i) {
    if (not std::isdigit(str[i])) {
      return false;
    }
  }
  return true;
}

bool IsStrArg(std::string_view str) {
  return str.size() and str[0] != '-';
}

int StrToInt(std::string_view str) {
  bool sign = (str[0] == '-');
  int res = 0;
  for (int i = sign; i < str.size(); ++i) {
    res = 10 * res + (str[i] - '0');
  }
  return (sign ? -res : res);
}

}

{{parser.name}}::{{ parser.name }}(const std::vector<std::string_view>& args) {
  {% for e in parser.options -%}
    {% if e.check_presense() -%}
      bool {{ e.name }}_found = false;
    {%- endif %}
  {%- endfor %}

{% macro consume_args(e) -%}
  {% if e.check_presense() %}
    {{ e.name }}_found = true;
  {% endif %}
  {% if e.typename() == 'bool' -%}
    {{ e.cpp_name() }} = true;
  {%- endif %}
  {% if e.typename() == 'int' -%}
    if (i + 1 < argc and IsIntArg(args[i + 1])) {
      {{ e.cpp_name() }} = StrToInt(args[++i]);
    } else {
      {{ e.cpp_name() }} = 1;
    }
  {%- endif %}
  {% if e.typename() == 'str' -%}
    if (i + 1 < argc and IsStrArg(args[i + 1])) {
      {{ e.cpp_name() }} = args[++i];
    } else {
      {{ e.cpp_name() }} = "";
    }
  {%- endif %}
  {% if e.typename() == ['str'] -%}
    std::vector<std::string_view> got;
    ++i;
    for (; i < argc and IsStrArg(args[i]); ++i) {
      got.push_back(args[i]);
    }
    {{ e.cpp_name() }} = std::move(got);
  {%- endif %}
  {% if e.typename() == ['int'] -%}
    std::vector<int> got;
    ++i;
    for (; i < argc and IsIntArg(args[i]); ++i) {
      got.push_back(StrToInt(args[i]));
    }
    {{ e.cpp_name() }} = std::move(got);
  {%- endif %}
{%- endmacro %}

  const int argc = args.size();
  for (int i = 0; i < argc; ++i) {
    const auto flag_name = args[i];
    if (IsStrArg(flag_name)) {
      positionals.push_back(flag_name);
      continue;
    }
    {% for e in parser.options %}
      // trying {{ e.name }}
      if (flag_name == "{{ e.full }}") {
        {{ consume_args(e) }}
        continue;
      }
      {% if e.char -%}
        // {{ e.name }} short option
        if (flag_name.substr(0, 2) == "{{ e.char }}") {
          {% if e.typename() == 'int' -%}
            if (flag_name.size() > 2) {
              {% if e.check_presense() %}
                {{ e.name }}_found = true;
              {% endif %}
              {{ e.cpp_name() }} = flag_name.size() - 1;
              continue;
            }
          {%- endif %}
          {{ consume_args(e) }}
          continue;
        }
      {%- endif %}
    {%- endfor %}
    throw std::runtime_error(std::string(flag_name) + " is unknown");
  }
  {% for e in parser.options -%}
    {% if e.check_presense() -%}
      if (not {{ e.name }}_found) {
        throw std::runtime_error("{{ e.name }} is required");
      }
    {% endif %}
  {% endfor %}
}

}
